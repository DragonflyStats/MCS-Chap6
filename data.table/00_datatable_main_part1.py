# -*- coding: utf-8 -*-
"""00-DataTable-MAIN-Part1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rsE7yVpMRF3z7rnteF1JDX-4BSVGwou7
"""

library(data.table)
library(magrittr)
library(ggplot2)

"""### data.table Tutorial

* The data.table R package is considered as the fastest package for data manipulation. This tutorial includes various examples and practice questions to make you familiar with the package. 
* Analysts generally call R programming not compatible with big datasets ( &gt; 10 GB) as it is not memory efficient and loads everything into RAM. 
* To change their perception, 'data.table' package comes into play. 
* This package was designed to be concise and painless. There are many benchmarks done in the past to compare dplyr vs data.table. In every benchmark, data.table performs well. 
* The efficiency of this package was also compared with python' package (panda). And data.table wins. In CRAN, there are more than 200 packages that are dependent on data.table which makes it listed in the top 5 R's package.

## data.table Syntax

The syntax of data.table is shown in the image below :<br />
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-L-DIRIa6pi4/WAdcNIhzCfI/AAAAAAAAFiE/RN9-bFU6rZAIfZpAbY9v8pLFRpoTHbQxACLcB/s1600/Data%2BTable%2BSyntax.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://2.bp.blogspot.com/-L-DIRIa6pi4/WAdcNIhzCfI/AAAAAAAAFiE/RN9-bFU6rZAIfZpAbY9v8pLFRpoTHbQxACLcB/s1600/Data%2BTable%2BSyntax.png" /></a></td></tr>

### Why use data.table()?
Why bother?

 Three main reasons:

* More efficient memory use
* Faster merging
* $[i, j]$ syntax incredibly powerful

### data.table Syntax

<b><span style="font-size: large;">DT[ i , j , by]</span></b><br />
<div>
<ol style="text-align: left;">
<li>The first parameter of data.table <b>i </b>refers to rows. It implies subsetting rows. It is equivalent to <b>WHERE </b>clause in SQL</li>
<li>The second parameter of data.table <b>j </b>refers to columns. It implies subsetting columns (dropping / keeping). It is equivalent to <b>SELECT </b>clause in SQL.</li>
<li>The third parameter of data.table <b>by </b>refers to adding a group so that all calculations would be done within a group. Equivalent to SQL's <b>GROUP BY</b> clause.</li>
</ol>
<div>

#### Introduction
data.table (DT) is very similar to a \texttt{data.frame} (DF)
"""

DF = data.frame(x = 1:3, y = c('a', 'b', 'c'));
DF

library(data.table)
DT = data.table(x = 1:3, y = c('a', 'b', 'c'));
print(DT)

"""Note the colon (`:') after row number

DT inherits from DF, so $\text{DF} \rightarrow \text{DT}$ easy.

"""

mtcars.dt <- data.table(mtcars)
mtcars.dt %>% head %>% print

"""``data.table`` truncates long output

"""

library(ggplot2)
diamonds.dt <- data.table(diamonds)
diamonds.dt

"""Row/Column referencing slightly different:"""

diamonds.dt[1:5] %>% print

diamonds.dt[, list(carat, cut, table)] %>% print

"""Note syntax of columns --- colnames not quoted (more later)

### Keys

DT can have key

* Index in SQL DBs
* Sorted by index
* Only one per DT
* Binary search
     
Huge speedup over vector scan

<b><span style="color: red;"><br /></span></b></div>
<div>
<b><span style="color: black;">The data.table syntax is NOT RESTRICTED to only 3 parameters.</span></b> There are other arguments that can be added to data.table syntax. The list is as follows -</div>
<div>
<ol style="text-align: left;">
<li>with, which</li>
<li>allow.cartesian</li>
<li>roll, rollends</li>
<li>.SD, .SDcols</li>
<li>on, mult, nomatch</li>
</ol>
</div>
</div>
<div>
"""

{DT[i, j, by = x]}

\texttt{DT[where, select | update, group-by] [having] [order by]}


\begin{itemize}
\item<2-> SQL-like syntax
\item<3-> Probably most powerful feature
\item<4-> $i$ is row-select, $j$ is row-output
\item<5-> `\texttt{by =}' allows for grouping
\end{itemize}

"""

The above arguments would be explained in the latter part of the post.</div>
<div>
<br /></div>
<b><span style="color: #000000; font-size: x-large;">How to Install and load data.table Package</span></b><br />
"""

# install.packages("data.table")
library(data.table)

"""### Read Data
* In data.table package, <b>fread() function </b>is available to read or get data from your computer or from a web page. It is equivalent to read.csv() function of base R.
"""

mydata = fread("https://raw.githubusercontent.com/arunsrinivasan/satrdays-workshop/master/flights_2014.csv")

"""### Describe Data

* This dataset contains 253K observations and 17 columns. 
* It constitutes information about flights' arrival or departure time, delays, flight cancellation and destination in year 2014.
"""

nrow(mydata);
ncol(mydata);

class(mydata)

names(mydata)

"""### Selecting or Keeping Columns
Suppose you need to select only 'origin' column. You can use the code below


"""

dat1 = mydata[ , origin] # returns a vector

"""The above line of code returns a vector not data.table.

"""

class(dat1)

"""To get result in data.table format, run the code below :"""

# returns a data.table

dat1 = mydata[ , .(origin)]

"""It can also be written like ``data.frame`` way

"""

dat1 = mydata[, c("origin"), with=FALSE]

"""### Keeping a column based on column position

"""

dat2 =mydata[, 2, with=FALSE]

"""In this code, we are selecting <b>second column </b>from mydata<b>.

### Keeping Multiple Columns

The following code tells R to select 'origin', 'year', 'month', 'hour' columns.<br />
"""

dat3 = mydata[, .(origin, year, month, hour)]
print(dat3)

"""### Keeping multiple columns based on column position

You can keep second through fourth columns using the code below -<br />

"""

dat4 = mydata[, c(2:4), with=FALSE]
dat4 %>% print();

"""### Dropping a Column

Suppose you want to include all the variables except one column, say. 'origin'. 
It can be easily done by adding <b>! sign</b> (implies negation in R)<br />

"""

dat5 = mydata[, !c("origin"), with=FALSE]

"""### Dropping Multiple Columns

"""

dat6 = mydata[, !c("origin", "year", "month"), with=FALSE]

dat6 %>% head(2) %>% print()

"""### Keeping variables that contain 'dep'
You can use <b>``%like%``</b> operator to find pattern. 
It is same as <b>base R's ``grepl()`` function</b>,&nbsp;<b>SQL's LIKE </b>operator and <b>SAS's CONTAINS </b>function.

"""

dat7 = mydata[,names(mydata) %like% "dep", with=FALSE]
print(dat7)

"""
### Rename Variables

You can rename variables with <b>setnames()</b> function. In the following code, we are renaming a variable 'dest' to 'destination'.<br />
"""

setnames(mydata, c("dest"), c("Destination"))
setnames(mydata, c("origin"), c("origin.of.flight"))

"""To rename multiple variables, you can simply add variables in both the sides (*changing variable names back to original names*).

"""

setnames(mydata, c("Destination", "origin.of.flight"), c("dest", "origin"))

"""### Subsetting Rows / Filtering
Suppose you are asked to find all the flights whose origin is 'JFK'.


"""

# Filter based on one variable
dat8 = mydata[origin == "JFK"]

"""###  Select Multiple Values
Filter all the flights whose origin is either 'JFK' or 'LGA'

"""

dat9 = mydata[origin %in% c("JFK", "LGA")]

"""### Apply Logical Operator : NOT

The following program selects all the flights whose origin is not equal to 'JFK' and 'LGA'<br />

"""

# Exclude Values
dat10 = mydata[!origin %in% c("JFK", "LGA")]

"""### Filter based on Multiple variables

If you need to select all the flights whose origin is equal to 'JFK' and carrier = 'AA'<br />

"""

dat11 = mydata[origin == "JFK" & carrier == "AA"]

"""## Faster Data Manipulation with Indexing

data.table uses <b>binary search algorithm</b> that makes data manipulation faster.

### Binary Search Algorithm
Binary search is an efficient algorithm for finding a value from a <b>sorted </b>list of values.&nbsp;It involves repeatedly splitting in half the portion of the list that contains values, until you found the value that you were searching for.

Suppose you have the following values in a variable :<br />
$$ \{5, 10, 7, 20, 3, 13, 26\} $$
You are searching the value <b>20&nbsp;</b>in the above list. See how binary search algorithm works -<br />
<br />

<ol style="text-align: left;">
<li>First, we sort the values&nbsp;</li>
<li>We would calculate the middle value i.e. 10.</li>
<li>We would check whether 20 = 10? No. 20 &lt; 10.</li>
<li>Since 20 is greater than 10, it should be somewhere after 10. So we can ignore all the values that are lower than or equal to 10.</li>
<li>We are left with 13, 20, 26. The middle value is 20.&nbsp;</li>
<li>We would again check whether 20=20. Yes. the match found.</li>
</ol>
<br />

If we do not use this algorithm, we would have to search 5 in the whole list of seven values.<br />
<br />
It is important to set <b>key </b>in your dataset which tells system that data is sorted by the key column. For example, you have employee&#8217;s name, address, salary, designation, department, employee ID. We can use 'employee ID' as a key to search a particular employee.<br />
<b><span style="font-size: large;"><br /></span></b>
<b><span style="font-size: large;">Set Key</span></b><br />
<br />

In this case, we are setting <b>'origin'</b> as a key in the dataset <b>mydata</b>.<br />

<b>Note : </b>It makes the data table <b>sorted </b>by the column 'origin'.<br />
<br />
"""

# Indexing (Set Keys)
setkey(mydata, origin)

"""
### How to filter when key is turned on.

You don't need to refer the key column when you apply filter.<br />
"""

data12 = mydata[c("JFK", "LGA")]

